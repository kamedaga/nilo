# Nilo State Proc Macros

This document summarizes the attribute macros to extend Nilo state behavior from Rust.

Supported macros:
- `#[nilo_state_watcher]` — call a function when a specific state field changes
- `#[nilo_state_assign]` — generate a helper that assigns a Rust value to a Nilo state field
- `#[nilo_state_validator]` — register a validator run after a field changes

These macros work with the `StateAccess` implementation generated by `#[derive(StateAccess)]`.

## nilo_state_watcher

Invoke a function whenever one or more fields on a specific state type are updated.

Signature: `fn(&mut State)`

Example:

```rust
use nilo::engine::state::StateAccess;
use nilo::{nilo_state_watcher};

#[derive(Debug, Clone, Default)]
struct MyState { counter: i32, name: String }

#[nilo_state_watcher(state = MyState, fields("counter", "name"))]
fn on_state_change(state: &mut MyState) {
    // Runs after either field is modified
    let v = state.get_field("counter").unwrap();
    println!("counter changed -> {}", v);
}
```

Notes:
- Works on native targets; `linkme` registration is disabled on `wasm32`.
- Uses the engine registry: changes trigger via `notify_state_watchers` inside generated `StateAccess` impl.

## nilo_state_assign

Generate a function body that assigns a Rust value to a given state field, converting to `String` for the `StateAccess::set` API. This keeps conversions and error propagation consistent.

Attribute parameters:
- `state = <Type>` — state struct type
- `field = "name"` — target field key as string

Function requirements:
- Signature: `fn(&mut State, value: T) -> Result<(), String>`
- `T` must be one of: `String`, `&str`, `bool`, integer types (`i8..i128`, `u8..u128`), `f32`, `f64`.

Example:

```rust
use nilo::nilo_state_assign;

#[nilo_state_assign(state = MyState, field = "counter")]
fn set_counter(state: &mut MyState, value: i32) -> Result<(), String> { unreachable!() }

#[nilo_state_assign(state = MyState, field = "name")]
fn set_name(state: &mut MyState, value: &str) -> Result<(), String> { unreachable!() }
```

The macro replaces the function body with a call to `state.set("field", value_as_string)` and returns the `Result`.

Notes:
- Vector/list fields are not supported by `nilo_state_assign`. Use the list helpers: `list_append`, `list_insert`, `list_remove`, `list_clear` generated by `StateAccess`.

## nilo_state_validator

Register a validator that runs after a specific field is modified. The validator function receives the current field value parsed into the function’s argument type.

Attribute parameters:
- `state = <Type>` — state struct type
- `field = "name"` — target field key

Function requirements:
- Signature: `fn(value: T) -> bool` or `fn(value: T) -> Result<(), String>`
- `T` must be a supported scalar: `String`, `bool`, integers, or floats.

Example (bool result):

```rust
use nilo::nilo_state_validator;

#[nilo_state_validator(state = MyState, field = "counter")]
fn validate_counter(v: i32) -> bool {
    v >= 0 && v <= 1000
}
```

Example (Result):

```rust
#[nilo_state_validator(state = MyState, field = "name")]
fn validate_name(v: String) -> Result<(), String> {
    if v.trim().is_empty() { Err("name must not be empty".into()) } else { Ok(()) }
}
```

Behavior:
- On change, the watcher parses the field value to `T` and calls your function.
- If it returns `false` or `Err`, an error is logged with state and field.
- Validators do not prevent the assignment nor revert the change (non-invasive). If you need to enforce constraints before assignment, add your checks in app logic before calling setters or create a custom setter that validates first and only then calls `set`.

## Tips

- Ensure you call `nilo::init_nilo_functions()` (which also initializes state watchers) early in your `main`.
- For custom lists (`Vec<T>`), use the list methods exposed by `AppState` or your `CustomStateContext`.
- If you need to run side effects on field changes, prefer `#[nilo_state_watcher]`.

